diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index bbe1887623..9a5d6b2347 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -546,6 +546,7 @@ dtb-$(CONFIG_MACH_SUN8I_R40) += \
 	sun8i-r40-bananapi-m2-ultra.dtb \
 	sun8i-v40-bananapi-m2-berry.dtb
 dtb-$(CONFIG_MACH_SUN8I_V3S) += \
+	sun8i-v3s-prince.dtb \
 	sun8i-v3s-licheepi-zero.dtb 
 dtb-$(CONFIG_MACH_SUN8I_S3) += \
 	sun8i-s3-generic.dtb
diff --git a/arch/arm/include/asm/arch-sunxi/clock_sun6i.h b/arch/arm/include/asm/arch-sunxi/clock_sun6i.h
index 8001a81b8f..6c015f2f94 100644
--- a/arch/arm/include/asm/arch-sunxi/clock_sun6i.h
+++ b/arch/arm/include/asm/arch-sunxi/clock_sun6i.h
@@ -463,6 +463,7 @@ struct sunxi_ccm_reg {
 #ifdef CONFIG_MACH_SUN8I_R40
 #define AHB_RESET_OFFSET_SATA		24
 #endif
+#define AHB_RESET_OFFSET_OTG		24
 #define AHB_RESET_OFFSET_GMAC		17
 #define AHB_RESET_OFFSET_MCTL		14
 #define AHB_RESET_OFFSET_MMC3		11
diff --git a/arch/arm/mach-sunxi/Kconfig b/arch/arm/mach-sunxi/Kconfig
index b7cb87a98f..0d053b8087 100644
--- a/arch/arm/mach-sunxi/Kconfig
+++ b/arch/arm/mach-sunxi/Kconfig
@@ -1,7 +1,7 @@
 if ARCH_SUNXI
 
 config SPL_LDSCRIPT
-	default "arch/arm/cpu/armv7/sunxi/u-boot-spl.lds" if !ARM64
+	default "arch/arm/cpu/armv7/sunxi/u-boot-spl.lds" if !ARM64 || MACH_SUN8I_V3S || MACH_SUN8I_S3
 
 config IDENT_STRING
 	default " Allwinner Technology"
@@ -262,6 +262,7 @@ config MACH_SUN8I_V3S
 	select SUNXI_DRAM_DW
 	select SUNXI_DRAM_DW_16BIT
 	select SUPPORT_SPL
+	select SUNXI_DE2
 
 config MACH_SUN8I_S3
 	bool "sun8i (Allwinner S3)"
@@ -1006,13 +1007,55 @@ config SPL_STACK_R_ADDR
 	default 0x4fe00000 if MACH_SUN50I_H6
 
 config SPL_SPI_SUNXI
-	bool "Support for SPI Flash on Allwinner SoCs in SPL"
-	depends on MACH_SUN4I || MACH_SUN5I || MACH_SUN7I || MACH_SUNXI_H3_H5 || MACH_SUN50I || MACH_SUN8I_R40 || MACH_SUN50I_H6
+	bool "Support for SPI (NOR) Flash on Allwinner SoCs in SPL"
+	depends on MACH_SUN4I || MACH_SUN5I || MACH_SUN7I || MACH_SUNXI_H3_H5 || MACH_SUN50I || MACH_SUN8I_R40 || MACH_SUN50I_H6 || MACH_SUN8I_V3S || MACH_SUN8I_S3
 	help
 	  Enable support for SPI Flash. This option allows SPL to read from
 	  sunxi SPI Flash. It uses the same method as the boot ROM, so does
 	  not need any extra configuration.
 
+config SPL_SPINAND_SUNXI
+	bool "Support for SPI NAND-Flash on Allwinner SoCs in SPL"
+	depends on MACH_SUN4I || MACH_SUN5I || MACH_SUN7I || MACH_SUNXI_H3_H5 || MACH_SUN50I || MACH_SUN8I_V3S || MACH_SUN8I_S3
+	help
+	  Enable support for SPI-NAND Flash. This option allows SPL to read from
+	  sunxi SPI-NAND Flash. It needs further configuration to calculate all offsets correctly.
+
+config SPL_SPINAND_SUNXI_SPL_SIZE
+	int "Expected SPL size after padding to blocksize"
+	depends on SPL_SPINAND_SUNXI
+	default 24576
+	help
+	  The sunxi BROM is only able to load 1KB per page when booting from spi-nand.
+	  Thus the SPL is getting chunked to 1KB pages in spi-nand. To correctly calculate
+	  the address of u-boot it is thus neccessary to know the size of the SPL in 
+	  spi-nand.
+
+config SPL_SPINAND_SUNXI_UBOOT_PADDING
+	int "Offset between SPL and u-boot"
+	depends on SPL_SPINAND_SUNXI
+	default 8192
+	help
+	  u-boot is placed with an offset between SPL. To correctly calculate
+	  the address of u-boot it is thus neccessary to know the offset. 
+
+config SPL_SPINAND_SUNXI_PAGESIZE
+	int "NAND pagesize in KB"
+	depends on SPL_SPINAND_SUNXI
+	default 2048
+	help
+	  The sunxi BROM is only able to load 1KB per page when booting from spi-nand.
+	  Thus the SPL is getting chunked to 1KB pages in spi-nand. To correctly calculate
+	  the address of u-boot it is thus neccessary to know the page size of the spi-nand. 
+
+config SPL_SPINAND_SUNXI_SPL_USE_GENERIC2K
+	bool "Generic SPI-NAND config with 2K page-size"
+	depends on SPL_SPINAND_SUNXI
+	default n
+	help
+	  If no known spi-nand is found, try with generic settings for spi-nand with a
+	  page-size of 2K.
+
 config PINE64_DT_SELECTION
 	bool "Enable Pine64 device tree selection code"
 	depends on MACH_SUN50I
diff --git a/arch/arm/mach-sunxi/Makefile b/arch/arm/mach-sunxi/Makefile
index d129f33479..490901251c 100644
--- a/arch/arm/mach-sunxi/Makefile
+++ b/arch/arm/mach-sunxi/Makefile
@@ -36,6 +36,7 @@ obj-$(CONFIG_DRAM_SUN8I_A33)	+= dram_sun8i_a33.o
 obj-$(CONFIG_DRAM_SUN8I_A83T)	+= dram_sun8i_a83t.o
 obj-$(CONFIG_DRAM_SUN9I)	+= dram_sun9i.o
 obj-$(CONFIG_SPL_SPI_SUNXI)	+= spl_spi_sunxi.o
+obj-$(CONFIG_SPL_SPINAND_SUNXI)	+= spl_spinand_sunxi.o
 obj-$(CONFIG_SUNXI_DRAM_DW)	+= dram_sunxi_dw.o
 obj-$(CONFIG_SUNXI_DRAM_DW)	+= dram_timings/
 obj-$(CONFIG_DRAM_SUN50I_H6)	+= dram_sun50i_h6.o
diff --git a/arch/arm/mach-sunxi/board.c b/arch/arm/mach-sunxi/board.c
index 6aa28bbc3c..35c4293fd6 100644
--- a/arch/arm/mach-sunxi/board.c
+++ b/arch/arm/mach-sunxi/board.c
@@ -223,6 +223,12 @@ void s_init(void)
 
 #define SUNXI_INVALID_BOOT_SOURCE	-1
 
+#if defined(CONFIG_MACH_SUN8I_V3S) || defined(CONFIG_MACH_SUN8I_S3)
+static int sunxi_get_boot_source(void)
+{
+	return (s8)readb(SPL_ADDR + 0x6fff);
+}
+#else
 static int sunxi_get_boot_source(void)
 {
 	if (!is_boot0_magic(SPL_ADDR + 4)) /* eGON.BT0 */
@@ -230,7 +236,7 @@ static int sunxi_get_boot_source(void)
 
 	return readb(SPL_ADDR + 0x28);
 }
-
+#endif
 /* The sunxi internal brom will try to loader external bootloader
  * from mmc0, nand flash, mmc2.
  */
@@ -293,12 +299,32 @@ unsigned long spl_mmc_get_uboot_raw_sector(struct mmc *mmc)
 
 	return sector;
 }
-
+#if defined(CONFIG_MACH_SUN8I_V3S) || defined(CONFIG_MACH_SUN8I_S3)
 u32 spl_boot_device(void)
 {
 	return sunxi_get_boot_device();
 }
+#else
+/*
+ * suniv BROM do not pass the boot media type to SPL, so we try with the
+ * boot sequence in BROM: mmc0->spinor->fail.
+ */
+void board_boot_order(u32 *spl_boot_list)
+{
+	/*
+	 * See the comments above in sunxi_get_boot_device() for infomation
+	 * about FEL boot.
+	 */
+	if (!is_boot0_magic(SPL_ADDR + 4)) {
+		spl_boot_list[0] = BOOT_DEVICE_BOARD;
+		return;
+	}
 
+	spl_boot_list[0] = BOOT_DEVICE_MMC1;
+	spl_boot_list[1] = BOOT_DEVICE_MMC2;
+	spl_boot_list[2] = BOOT_DEVICE_SPI;
+}
+#endif
 void board_init_f(ulong dummy)
 {
 	spl_init();
@@ -343,7 +369,7 @@ void reset_cpu(ulong addr)
 #endif
 }
 
-#if !CONFIG_IS_ENABLED(SYS_DCACHE_OFF) && !defined(CONFIG_ARM64)
+#if !CONFIG_IS_ENABLED(SYS_DCACHE_OFF) && !defined(CONFIG_ARM64) && !defined(CONFIG_MACH_SUN8I_V3S) && !defined(CONFIG_MACH_SUN8I_S3)
 void enable_caches(void)
 {
 	/* Enable D-cache. I-cache is already enabled in start.S */
diff --git a/arch/arm/mach-sunxi/spl_spinand_sunxi.c b/arch/arm/mach-sunxi/spl_spinand_sunxi.c
new file mode 100644
index 0000000000..b231a4678b
--- /dev/null
+++ b/arch/arm/mach-sunxi/spl_spinand_sunxi.c
@@ -0,0 +1,759 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 Benedikt-Alexander Mokro√ü <bam@icognize.de>
+ */
+
+#include <common.h>
+#include <spl.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <mapmem.h>
+#include <linux/libfdt.h>
+
+#ifdef CONFIG_SPL_OS_BOOT
+#error CONFIG_SPL_OS_BOOT is not supported yet
+#endif
+
+/*
+ * This is a very simple U-Boot image loading implementation, trying to
+ * replicate what the boot ROM is doing when loading the SPL. Because we
+ * know the exact pins where the SPI Flash is connected and also know
+ * that the Read Data Bytes (03h) command is supported, the hardware
+ * configuration is very simple and we don't need the extra flexibility
+ * of the SPI framework. Moreover, we rely on the default settings of
+ * the SPI controler hardware registers and only adjust what needs to
+ * be changed. This is good for the code size and this implementation
+ * adds less than 400 bytes to the SPL.
+ *
+ * There are two variants of the SPI controller in Allwinner SoCs:
+ * A10/A13/A20 (sun4i variant) and everything else (sun6i variant).
+ * Both of them are supported.
+ *
+ * The pin mixing part is SoC specific and only A10/A13/A20/H3/A64 are
+ * supported at the moment.
+ */
+
+/*****************************************************************************/
+/* SUN4I variant of the SPI controller                                       */
+/*****************************************************************************/
+
+#define SUN4I_SPI0_CCTL             (0x01C05000 + 0x1C)
+#define SUN4I_SPI0_CTL              (0x01C05000 + 0x08)
+#define SUN4I_SPI0_RX               (0x01C05000 + 0x00)
+#define SUN4I_SPI0_TX               (0x01C05000 + 0x04)
+#define SUN4I_SPI0_FIFO_STA         (0x01C05000 + 0x28)
+#define SUN4I_SPI0_BC               (0x01C05000 + 0x20)
+#define SUN4I_SPI0_TC               (0x01C05000 + 0x24)
+
+#define SUN4I_CTL_ENABLE            BIT(0)
+#define SUN4I_CTL_MASTER            BIT(1)
+#define SUN4I_CTL_TF_RST            BIT(8)
+#define SUN4I_CTL_RF_RST            BIT(9)
+#define SUN4I_CTL_XCH               BIT(10)
+
+/*****************************************************************************/
+/* SUN6I variant of the SPI controller                                       */
+/*****************************************************************************/
+
+#define SUN6I_SPI0_CCTL             (0x01C68000 + 0x24)
+#define SUN6I_SPI0_GCR              (0x01C68000 + 0x04)
+#define SUN6I_SPI0_TCR              (0x01C68000 + 0x08)
+#define SUN6I_SPI0_FIFO_STA         (0x01C68000 + 0x1C)
+#define SUN6I_SPI0_WCR				(0x01C68000 + 0x20)
+#define SUN6I_SPI0_MBC              (0x01C68000 + 0x30)
+#define SUN6I_SPI0_MTC              (0x01C68000 + 0x34)
+#define SUN6I_SPI0_BCC              (0x01C68000 + 0x38)
+#define SUN6I_SPI0_TXD              (0x01C68000 + 0x200)
+#define SUN6I_SPI0_RXD              (0x01C68000 + 0x300)
+
+#define SUN6I_CTL_ENABLE            BIT(0)
+#define SUN6I_CTL_MASTER            BIT(1)
+#define SUN6I_CTL_SRST              BIT(31)
+#define SUN6I_TCR_XCH               BIT(31)
+
+/*****************************************************************************/
+
+#define CCM_AHB_GATING0             (0x01C20000 + 0x60)
+#define CCM_SPI0_CLK                (0x01C20000 + 0xA0)
+#define SUN6I_BUS_SOFT_RST_REG0     (0x01C20000 + 0x2C0)
+
+#define AHB_RESET_SPI0_SHIFT        20
+#define AHB_GATE_OFFSET_SPI0        20
+
+#define SPI0_CLK_DIV_NONE			0x0000
+#define SPI0_CLK_DIV_BY_2           0x1000
+#define SPI0_CLK_DIV_BY_4           0x1001
+#define SPI0_CLK_DIV_BY_32          0x100f
+
+#define DUMMY_BURST_BYTE 			0x00
+
+#define EGON_BTO_HEADER_SIZE 40
+
+#ifndef CONFIG_SPL_SPINAND_SUNXI_SPL_SIZE
+#define CONFIG_SPL_SPINAND_SUNXI_SPL_SIZE 		0x6000
+#endif
+#ifndef CONFIG_SPL_SPINAND_SUNXI_UBOOT_PADDING
+#define CONFIG_SPL_SPINAND_SUNXI_UBOOT_PADDING 	0x2000
+#endif
+#ifndef CONFIG_SPL_SPINAND_SUNXI_PAGESIZE
+#define CONFIG_SPL_SPINAND_SUNXI_PAGESIZE 		2048
+#endif
+#ifndef CONFIG_SYS_SPI_U_BOOT_OFFS
+#define CONFIG_SYS_SPI_U_BOOT_OFFS (CONFIG_SPL_SPINAND_SUNXI_SPL_SIZE * (CONFIG_SPL_SPINAND_SUNXI_PAGESIZE / 1024)) + CONFIG_SPL_SPINAND_SUNXI_UBOOT_PADDING
+#endif
+
+/* Somhow dcrc is failing even if the u-boot is valid */
+#undef CONFIG_SPL_SPINAND_SUNXI_SPL_CHECK_DCRC
+
+/*****************************************************************************/
+
+struct sunxi_nand_config {
+	const char* name;
+	u32 jedec_id;
+	u32 page_mask;
+	u8 page_shift;
+	u32 addr_mask;
+	u8 addr_shift;
+	u32 block_size;
+	u32 page_size;
+};
+
+struct egon_bt0_header {
+	u32 jump;
+	const u8 magic[8]; /* eGON.BT0 */
+	u32 checksum;
+	u32 length;
+	u32 header_size;
+	u8 header_version[4];
+	u8 boot_vsn[4];
+	u8 egon_vsn[4];
+	u8 platform[8];
+};
+
+/*****************************************************************************/
+
+static const u8 egon_bt0_magic[8] = {'e','G','O','N','.','B','T','0'};
+static const char* spl_name = "sunxi SPI-NAND";
+
+struct sunxi_nand_config sunxi_known_nands[] = {
+	{
+		.name = "Macronix MX35LF1GE4AB",
+		.jedec_id = 0x00C212C2, /* MX35LFxGE4AB repeat the C2x2 over and over again */
+		.page_mask = 0x00FFFFFF,
+		.page_shift = 11,
+		.addr_mask = 0x7FF,
+		.addr_shift = 0,
+		.block_size = 128 * 1024,
+		.page_size = 2048,
+	},
+	{
+		.name = "Macronix MX35LF2GE4AB",
+		.jedec_id = 0x00C222C2,
+		.page_mask = 0x00FFFFFF,
+		.page_shift = 11,
+		.addr_mask = 0x7FF,
+		.addr_shift = 0,
+		.block_size = 128 * 1024,
+		.page_size = 2048,
+	},
+	{
+		.name = "Winbond W25N01GVxxIG",
+		.jedec_id = 0x00EFAA21,
+		.page_mask = 0x0000FFFF,
+		.page_shift = 11,
+		.addr_mask = 0x7FF,
+		.addr_shift = 0,
+		.block_size = 128 * 1024,
+		.page_size = 2048,
+	},
+	{
+		.name = "GigaDevice GD5F1GQ4RCxxG",
+		.jedec_id = 0x00C8B148, /* 3.3v */
+		.page_mask = 0x00FFFFFF,
+		.page_shift = 11,
+		.addr_mask = 0x7FF,
+		.addr_shift = 0,
+		.block_size = 128 * 1024,
+		.page_size = 2048,
+	},
+	{
+		.name = "GigaDevice GD5F1GQ4RCxxG",
+		.jedec_id = 0x00C8A148, /* 1.8V */
+		.page_mask = 0x00FFFFFF,
+		.page_shift = 11,
+		.addr_mask = 0x7FF,
+		.addr_shift = 0,
+		.block_size = 128 * 1024,
+		.page_size = 2048,
+	},
+
+	{ /* Sentinel */
+		.name = NULL,
+	}
+};
+
+#ifdef CONFIG_SPL_SPINAND_SUNXI_SPL_USE_GENERIC2K
+struct sunxi_nand_config sunxi_generic_nand_config = {
+	.name = "Generic 2K SPI-NAND",
+	.jedec_id = 0xFFFFFFFF,
+	.page_mask = 0x00FFFFFF,
+	.page_shift = 11,
+	.addr_mask = 0x7FF,
+	.addr_shift = 0,
+	.block_size = 128 * 1024,
+	.page_size = 2048,
+};
+#endif
+
+/*
+ * Enumerate all known nands and return the config if found.
+ * Returns NULL if none is found
+ */
+static struct sunxi_nand_config* sunxi_spinand_enumerate(u32 jedec_id)
+{
+	struct sunxi_nand_config* ptr = sunxi_known_nands;
+	while(ptr->name != NULL) {
+		if(jedec_id == ptr->jedec_id) {
+			return ptr;
+		}
+		++ptr;
+	}
+#ifdef CONFIG_SPL_SPINAND_SUNXI_SPL_USE_GENERIC2K
+	return &sunxi_generic_nand_config;
+#else
+	return NULL;
+#endif
+}
+
+/*
+ * Allwinner A10/A20 SoCs were using pins PC0,PC1,PC2,PC23 for booting
+ * from SPI Flash, everything else is using pins PC0,PC1,PC2,PC3.
+ */
+static void spi0_pinmux_setup(unsigned int pin_function)
+{
+	unsigned int pin;
+
+	for (pin = SUNXI_GPC(0); pin <= SUNXI_GPC(2); pin++)
+		sunxi_gpio_set_cfgpin(pin, pin_function);
+
+	if (IS_ENABLED(CONFIG_MACH_SUN4I) || IS_ENABLED(CONFIG_MACH_SUN7I))
+		sunxi_gpio_set_cfgpin(SUNXI_GPC(23), pin_function);
+	else
+		sunxi_gpio_set_cfgpin(SUNXI_GPC(3), pin_function);
+}
+
+/*
+ * Setup 24 MHz from OSC24M.
+ */
+static void spi0_enable_clock(void)
+{
+	/* Deassert SPI0 reset on SUN6I */
+	if (IS_ENABLED(CONFIG_SUNXI_GEN_SUN6I))
+		setbits_le32(SUN6I_BUS_SOFT_RST_REG0,
+			     (1 << AHB_RESET_SPI0_SHIFT));
+
+	/* Open the SPI0 gate */
+	setbits_le32(CCM_AHB_GATING0, (1 << AHB_GATE_OFFSET_SPI0));
+
+	/* No devide */
+	writel(SPI0_CLK_DIV_NONE, IS_ENABLED(CONFIG_SUNXI_GEN_SUN6I) ?
+				  SUN6I_SPI0_CCTL : SUN4I_SPI0_CCTL);
+	/* 24MHz from OSC24M */
+	writel((1 << 31), CCM_SPI0_CLK);
+
+	if (IS_ENABLED(CONFIG_SUNXI_GEN_SUN6I)) {
+		/* Enable SPI in the master mode and do a soft reset */
+		setbits_le32(SUN6I_SPI0_GCR, SUN6I_CTL_MASTER |
+					     SUN6I_CTL_ENABLE |
+					     SUN6I_CTL_SRST);
+		/* Wait for completion */
+		while (readl(SUN6I_SPI0_GCR) & SUN6I_CTL_SRST)
+			;
+	} else {
+		/* Enable SPI in the master mode and reset FIFO */
+		setbits_le32(SUN4I_SPI0_CTL, SUN4I_CTL_MASTER |
+					     SUN4I_CTL_ENABLE |
+					     SUN4I_CTL_TF_RST |
+					     SUN4I_CTL_RF_RST);
+	}
+}
+
+static void spi0_disable_clock(void)
+{
+	/* Disable the SPI0 controller */
+	if (IS_ENABLED(CONFIG_SUNXI_GEN_SUN6I))
+		clrbits_le32(SUN6I_SPI0_GCR, SUN6I_CTL_MASTER |
+					     SUN6I_CTL_ENABLE);
+	else
+		clrbits_le32(SUN4I_SPI0_CTL, SUN4I_CTL_MASTER |
+					     SUN4I_CTL_ENABLE);
+
+	/* Disable the SPI0 clock */
+	writel(0, CCM_SPI0_CLK);
+
+	/* Close the SPI0 gate */
+	clrbits_le32(CCM_AHB_GATING0, (1 << AHB_GATE_OFFSET_SPI0));
+
+	/* Assert SPI0 reset on SUN6I */
+	if (IS_ENABLED(CONFIG_SUNXI_GEN_SUN6I))
+		clrbits_le32(SUN6I_BUS_SOFT_RST_REG0,
+			     (1 << AHB_RESET_SPI0_SHIFT));
+}
+
+static void spi0_init(void)
+{
+	unsigned int pin_function = SUNXI_GPC_SPI0;
+	if (IS_ENABLED(CONFIG_MACH_SUN50I))
+		pin_function = SUN50I_GPC_SPI0;
+
+	spi0_pinmux_setup(pin_function);
+	spi0_enable_clock();
+
+	writel(0x01, SUN6I_SPI0_WCR);
+}
+
+static void spi0_deinit(void)
+{
+	/* New SoCs can disable pins, older could only set them as input */
+	unsigned int pin_function = SUNXI_GPIO_INPUT;
+	if (IS_ENABLED(CONFIG_SUNXI_GEN_SUN6I))
+		pin_function = SUNXI_GPIO_DISABLE;
+
+	spi0_disable_clock();
+	spi0_pinmux_setup(pin_function);
+}
+
+/*****************************************************************************/
+
+#define SPI_READ_MAX_SIZE 60 /* FIFO size, minus 4 bytes of the header */
+
+static void sunxi_spi0_load_page(struct sunxi_nand_config * config, u32 addr, ulong spi_ctl_reg,
+				 ulong spi_ctl_xch_bitmask,
+				 ulong spi_fifo_reg,
+				 ulong spi_tx_reg,
+				 ulong spi_rx_reg,
+				 ulong spi_bc_reg,
+				 ulong spi_tc_reg,
+				 ulong spi_bcc_reg) {
+
+    /* Read Page in Cache */
+	u8 status = 0x01;
+	addr = addr >> (config->page_shift);
+	addr = addr & (config->page_mask);
+
+	writel(4, spi_bc_reg); /* Burst counter (total bytes) */
+	writel(4, spi_tc_reg);           /* Transfer counter (bytes to send) */
+	if (spi_bcc_reg)
+		writel(4, spi_bcc_reg);  /* SUN6I also needs this */
+
+	/* Send the Read Data Bytes (13h) command header */
+	writeb(0x13, spi_tx_reg);
+	writeb((u8)(addr >> 16), spi_tx_reg);
+	writeb((u8)(addr >> 8),  spi_tx_reg);
+	writeb((u8)(addr),       spi_tx_reg);
+
+	/* Start the data transfer */
+	setbits_le32(spi_ctl_reg, spi_ctl_xch_bitmask);
+
+	/* Wait till all bytes are send */
+	while((readl(spi_fifo_reg) & 0x7F0000) > 0)
+		;
+
+    /* wait till all bytes are read */
+	while ((readl(spi_fifo_reg) & 0x7F) < 4)
+		;
+
+	/* Discard the 4 empty bytes from our send */
+	readl(spi_rx_reg);
+
+	do {
+		/* tCS = 100ns + tRD_ECC 70ns -> 200ns wait */
+		ndelay(200);
+
+		/* Poll */
+		writel(2 + 1, spi_bc_reg);   /* Burst counter (total bytes) */
+		writel(2, spi_tc_reg);       /* Transfer counter (bytes to send) */
+		if (spi_bcc_reg)
+			writel(2, spi_bcc_reg);  /* SUN6I also needs this */
+		/* Send the Read Status Bytes (0FC0h) command header */
+		writeb(0x0F, spi_tx_reg);
+		writeb(0xC0, spi_tx_reg);
+
+		/* Start the data transfer */
+		setbits_le32(spi_ctl_reg, spi_ctl_xch_bitmask);
+
+		while ((readl(spi_fifo_reg) & 0x7F) < 2 + 1)
+			;
+
+		/* skip 2 since we send 2 */
+	    readb(spi_rx_reg);
+		readb(spi_rx_reg);
+
+		status = readb(spi_rx_reg);
+
+	} while ((status & 0x01) == 0x01);
+
+}
+
+static void spi0_load_page(struct sunxi_nand_config * config, u32 addr)
+{
+	if (IS_ENABLED(CONFIG_SUNXI_GEN_SUN6I)) {
+		sunxi_spi0_load_page(config, addr,
+				     SUN6I_SPI0_TCR,
+				     SUN6I_TCR_XCH,
+				     SUN6I_SPI0_FIFO_STA,
+				     SUN6I_SPI0_TXD,
+				     SUN6I_SPI0_RXD,
+				     SUN6I_SPI0_MBC,
+				     SUN6I_SPI0_MTC,
+				     SUN6I_SPI0_BCC);
+	} else {
+		sunxi_spi0_load_page(config, addr,
+				     SUN4I_SPI0_CTL,
+				     SUN4I_CTL_XCH,
+				     SUN4I_SPI0_FIFO_STA,
+				     SUN4I_SPI0_TX,
+				     SUN4I_SPI0_RX,
+				     SUN4I_SPI0_BC,
+				     SUN4I_SPI0_TC,
+				     0);
+	}
+}
+
+static void sunxi_spi0_read_data(struct sunxi_nand_config * config, u8 *buf, u32 addr, u32 bufsize,
+				 ulong spi_ctl_reg,
+				 ulong spi_ctl_xch_bitmask,
+				 ulong spi_fifo_reg,
+				 ulong spi_tx_reg,
+				 ulong spi_rx_reg,
+				 ulong spi_bc_reg,
+				 ulong spi_tc_reg,
+				 ulong spi_bcc_reg)
+{
+	addr = addr >> (config->addr_shift);
+	addr = addr & (config->addr_mask);
+
+	writel(4 + bufsize, spi_bc_reg); /* Burst counter (total bytes) */
+	writel(4, spi_tc_reg);           /* Transfer counter (bytes to send) */
+	if (spi_bcc_reg)
+		writel(4, spi_bcc_reg);  /* SUN6I also needs this */
+
+	/* Send the Read Data Bytes (0Bh) command header */
+	writeb(0x0B, spi_tx_reg);
+	writeb((u8)((addr >> 8)), spi_tx_reg);
+	writeb((u8)(addr), spi_tx_reg);
+	writeb(DUMMY_BURST_BYTE, spi_tx_reg);
+
+	/* Start the data transfer */
+	setbits_le32(spi_ctl_reg, spi_ctl_xch_bitmask);
+
+	/* Wait until everything is received in the RX FIFO */
+	while ((readl(spi_fifo_reg) & 0x7F) < 4 + bufsize)
+		;
+
+	/* Skip 4 bytes since we send 4 */
+	readl(spi_rx_reg);
+
+	/* Read the data */
+	while (bufsize-- > 0)
+		*buf++ = readb(spi_rx_reg);
+
+	/* tSHSL time is up to 100 ns in various SPI flash datasheets */
+	ndelay(100);
+}
+
+static void sunxi_spi0_read_cache(struct sunxi_nand_config * config, void *buf, u32 addr, u32 len) {
+
+	if (IS_ENABLED(CONFIG_SUNXI_GEN_SUN6I)) {
+			sunxi_spi0_read_data(config, buf, addr, len,
+					     SUN6I_SPI0_TCR,
+					     SUN6I_TCR_XCH,
+					     SUN6I_SPI0_FIFO_STA,
+					     SUN6I_SPI0_TXD,
+					     SUN6I_SPI0_RXD,
+					     SUN6I_SPI0_MBC,
+					     SUN6I_SPI0_MTC,
+					     SUN6I_SPI0_BCC);
+		} else {
+			sunxi_spi0_read_data(config, buf, addr, len,
+					     SUN4I_SPI0_CTL,
+					     SUN4I_CTL_XCH,
+					     SUN4I_SPI0_FIFO_STA,
+					     SUN4I_SPI0_TX,
+					     SUN4I_SPI0_RX,
+					     SUN4I_SPI0_BC,
+					     SUN4I_SPI0_TC,
+					     0);
+		}
+}
+
+static void spi0_read_data(struct sunxi_nand_config * config, void *buf, u32 addr, u32 len)
+{
+	u8 *buf8 = buf;
+	u32 chunk_len;
+	u32 curr_page;
+	u32 last_page = (addr >> (config->page_shift)) & (config->page_mask);
+
+	spi0_load_page(config, addr);
+
+	while (len > 0) {
+		curr_page = (addr >> (config->page_shift)) & (config->page_mask);
+		if(curr_page > last_page) {
+			spi0_load_page(config, addr);
+			last_page = curr_page;
+		}
+
+		chunk_len = len;
+		if (chunk_len > SPI_READ_MAX_SIZE) {
+			chunk_len = SPI_READ_MAX_SIZE;
+		}
+
+		if((((addr + chunk_len) >> (config->page_shift)) & (config->page_mask)) > curr_page) {
+			chunk_len = ((curr_page + 1) << (config->page_shift)) - addr;
+		}
+
+		sunxi_spi0_read_cache(config, buf8, addr, chunk_len);
+		len  -= chunk_len;
+		buf8 += chunk_len;
+		addr += chunk_len;
+	}
+}
+
+static u32 sunxi_spi0_read_id(ulong spi_ctl_reg,
+				 ulong spi_ctl_xch_bitmask,
+				 ulong spi_fifo_reg,
+				 ulong spi_tx_reg,
+				 ulong spi_rx_reg,
+				 ulong spi_bc_reg,
+				 ulong spi_tc_reg,
+				 ulong spi_bcc_reg)
+{
+	u8 idbuf[3];
+	writel(2 + 3, spi_bc_reg); /* Burst counter (total bytes) */
+	writel(2, spi_tc_reg);     /* Transfer counter (bytes to send) */
+	if (spi_bcc_reg)
+		writel(2, spi_bcc_reg);  /* SUN6I also needs this */
+
+	/* Send the Read ID Bytes (9Fh) command header */
+	writeb(0x9F, spi_tx_reg);
+	writeb(DUMMY_BURST_BYTE, spi_tx_reg);
+
+	/* Start the data transfer */
+	setbits_le32(spi_ctl_reg, spi_ctl_xch_bitmask);
+
+	/* Wait until everything is received in the RX FIFO */
+	while ((readl(spi_fifo_reg) & 0x7F) < 2 + 3)
+		;
+
+	/* Skip 2 bytes */
+	readb(spi_rx_reg);
+	readb(spi_rx_reg);
+
+	/* Read the data */
+	//while (bufsize-- > 0)
+	idbuf[0] = readb(spi_rx_reg);
+	idbuf[1] = readb(spi_rx_reg);
+	idbuf[2] = readb(spi_rx_reg);
+
+	/* tSHSL time is up to 100 ns in various SPI flash datasheets */
+	ndelay(100);
+
+	return idbuf[2] | (idbuf[1] << 8) | (idbuf[0] << 16);
+}
+
+static u32 spi0_read_id(void) {
+	if (IS_ENABLED(CONFIG_SUNXI_GEN_SUN6I)) {
+		return sunxi_spi0_read_id(
+				     SUN6I_SPI0_TCR,
+				     SUN6I_TCR_XCH,
+				     SUN6I_SPI0_FIFO_STA,
+				     SUN6I_SPI0_TXD,
+				     SUN6I_SPI0_RXD,
+				     SUN6I_SPI0_MBC,
+				     SUN6I_SPI0_MTC,
+				     SUN6I_SPI0_BCC);
+	} else {
+		return sunxi_spi0_read_id(
+				     SUN4I_SPI0_CTL,
+				     SUN4I_CTL_XCH,
+				     SUN4I_SPI0_FIFO_STA,
+				     SUN4I_SPI0_TX,
+				     SUN4I_SPI0_RX,
+				     SUN4I_SPI0_BC,
+				     SUN4I_SPI0_TC,
+				     0);
+	}
+}
+
+#ifdef DEBUG
+static void print_egon_header(struct egon_bt0_header * egon) {
+	printf("Jump: %x\n", egon->jump);
+	printf("Magic: %c%c%c%c%c%c%c%c\n",
+		egon->magic[0], egon->magic[1], egon->magic[2], egon->magic[3], 
+		egon->magic[4], egon->magic[5], egon->magic[6], egon->magic[7]);
+	printf("Check: %x\n", egon->checksum);
+	printf("Length: %x\n",egon->length);
+	printf("Hdrsz: %u\n",egon->header_size);
+	printf("Bootvsn: %c%c%c%c\n", egon->boot_vsn[0],egon->boot_vsn[1],egon->boot_vsn[2],egon->boot_vsn[3]);
+	printf("Egonvsn: %c%c%c%c\n", egon->egon_vsn[0],egon->egon_vsn[1],egon->egon_vsn[2],egon->egon_vsn[3]);
+	printf("Platform: %c%c%c%c%c%c%c%c\n",
+		egon->platform[0], egon->platform[1], egon->platform[2], egon->platform[3], 
+		egon->platform[4], egon->platform[5], egon->platform[6], egon->platform[7]);
+}
+#endif
+
+static u32 sunxi_spi0_count_spls(struct sunxi_nand_config * config, struct egon_bt0_header* self) {
+	u8 buffer[EGON_BTO_HEADER_SIZE];
+	struct egon_bt0_header * egon = (struct egon_bt0_header *)buffer;
+	u32 entry_pages[8] = {0, 32, 64, 96, 128, 160, 192, 224};
+	u32 entry_point;
+	u32 address;
+	u32 spls = 0;
+	u32 hits = 0;
+	for(entry_point = 0; entry_point < 8; ++entry_point) {
+		address = entry_pages[entry_point] * config->page_size;
+#ifdef DEBUG
+		printf("Searching for spl at entrypoint %u 0x%x\n", entry_point, address);
+#endif
+		spi0_load_page(config, address);
+		sunxi_spi0_read_cache(config, buffer, address, EGON_BTO_HEADER_SIZE);
+#ifdef DEBUG
+		print_egon_header(egon);
+#endif
+		if(strncmp(egon->magic, egon_bt0_magic, 8) == 0) {
+			++spls;
+		} else {
+			hits = 0;
+			if(egon->jump == self->jump) {
+				++hits;
+			}
+			if(egon->checksum == self->checksum) {
+				++hits;
+			}
+			if(egon->length == self->length) {
+				++hits;
+			}
+			if(egon->header_size == self->header_size) {
+				++hits;
+			}
+			if(strncmp(egon->header_version, self->header_version, 4) == 0) {
+				++hits;
+			}
+			if(strncmp(egon->boot_vsn, self->boot_vsn, 4) == 0) {
+				++hits;
+			}
+			if(strncmp(egon->egon_vsn, self->egon_vsn, 4) == 0) {
+				++hits;
+			}
+			if(strncmp(egon->platform, self->platform, 8) == 0) {
+				++hits;
+			}
+			if(hits > 4) { /* at least > 50% similarity */
+				++spls;
+			}
+		}
+	}
+	return spls;
+}
+
+/*****************************************************************************/
+
+static int spl_spi_load_image(struct spl_image_info *spl_image,
+								struct spl_boot_device *bootdev)
+{
+	int ret = 0;
+	u32 id = 0;
+	u32 uboot_offset;
+	u32 total_spl_size = 0;
+	u32 spls;
+	struct image_header *header;
+	struct sunxi_nand_config* config;
+	struct egon_bt0_header* egon;
+	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE);
+	
+	spi0_init();
+	id = spi0_read_id();
+
+	/*
+	 * If we receive only zeros, there is most definetly no device attached. 
+	 */
+	if(id == 0) {
+		spi0_deinit();
+		printf("%s: Received only zeros on jedec_id probe, assuming no spi-nand attached.\n",spl_name);
+		return -1;
+	}
+
+	/*
+	 * Check if device is known and compatible.
+	 */
+	config = sunxi_spinand_enumerate(id);
+	if(config == NULL) {
+		spi0_deinit();
+		printf("%s: Unknown chip %x\n", spl_name, id);
+		return -1;
+	}
+
+	printf("%s: Found %s (%x)\n", spl_name, config->name, id);
+
+	/*
+	 * eGON.BRM loads a valid SPL to 0x40000000 which is the DDR base
+	 * Thus 0x000000 is mapped to this 0x40000000 where the SPL is loaded to.
+	 * Since this SPL is running it was successfully validated by eGON.BRM
+	 * and we can safely assume that all values are valid!
+	 */
+	egon = (struct egon_bt0_header *)map_sysmem(0x00000000, EGON_BTO_HEADER_SIZE);
+#ifdef DEBUG
+	printf("Self: \n");
+	print_egon_header(egon);
+#endif
+	spls = sunxi_spi0_count_spls(config, egon);
+	total_spl_size = ((config->page_size*32) * (spls - 1)) + ((config->page_size/1024) * egon->length);
+	uboot_offset = (total_spl_size + config->block_size) - (total_spl_size % config->block_size);
+	unmap_sysmem(egon);
+#ifdef DEBUG
+	printf("Found %u spls\n", spls);
+	printf("total-spl-size 0x%x\n",total_spl_size);
+	printf("uboot-offset 0x%x\n", uboot_offset);
+#endif
+
+	do {
+		printf("%s: Loading u-boot from 0x%x\n", spl_name, uboot_offset);
+		ret = 1;
+		/*
+		 * Read the header data from the image and parse it for validity.
+		 */
+		spi0_read_data(config, (void *)header, uboot_offset, 0x40);
+		if(image_check_hcrc(header)) {
+			printf("%s: u-boot hcrc OK!\n", spl_name);
+			ret = spl_parse_image_header(spl_image, header);
+			if (ret) {
+				printf("spl_parse_image_header: %x\n", ret);
+				/*
+				 * The header was ok, so we can savely use the datasize to calculate the next PEB to look for an u-boot
+				 */
+				uboot_offset += (image_get_image_size(header) + config->block_size) - (image_get_image_size(header) % config->block_size);
+			} else {
+				/*
+				 * If everything is fine, read the rest of u-boot and start
+				 */
+				spi0_read_data(config, (void *)spl_image->load_addr, uboot_offset, spl_image->size);
+				#ifdef CONFIG_SPL_SPINAND_SUNXI_SPL_CHECK_DCRC
+				if (image_check_dcrc(header)) {
+					printf("%s: u-boot dcrc OK!\n", spl_name);
+				} else {
+					printf("%s: u-boot dcrc ERROR!\n", spl_name);
+					ret = 1;
+				}
+				#endif
+			}
+		} else {
+			printf("%s: u-boot hcrc ERROR!\n", spl_name);
+			uboot_offset += config->block_size; 
+		}
+	} while(ret != 0);
+
+	spi0_deinit();
+	return ret;
+}
+/* Use priorty 0 to override the default if it happens to be linked in */
+SPL_LOAD_IMAGE_METHOD("sunxi SPI-NAND", 0, BOOT_DEVICE_SPI, spl_spi_load_image);
diff --git a/board/sunxi/board.c b/board/sunxi/board.c
index 769530412b..dd82e284b0 100644
--- a/board/sunxi/board.c
+++ b/board/sunxi/board.c
@@ -846,6 +846,16 @@ static void setup_environment(const void *fdt)
 		}
 	}
 }
+static int usb_gadget_init(void)
+{
+	int ret;
+	struct udevice *usb_dev;
+	ret = uclass_first_device(UCLASS_USB_GADGET_GENERIC, &usb_dev);
+	if (!usb_dev || ret) {
+		pr_err("No USB gadget device found\n");
+	}
+	return ret;
+}
 
 int misc_init_r(void)
 {
@@ -867,12 +877,35 @@ int misc_init_r(void)
 		env_set("mmc_bootdev", "1");
 	}
 
+	switch (boot) {
+		case BOOT_DEVICE_MMC1:
+			env_set("boot_device", "mmc0");
+			break;
+		case BOOT_DEVICE_MMC2:
+			env_set("boot_device", "mmc1");
+			break;
+		case BOOT_DEVICE_SPI:
+			env_set("boot_device", "spi");
+			break;
+		default:
+			env_set("boot_device", "fel");
+			break;
+	}
+
 	setup_environment(gd->fdt_blob);
 
 #ifdef CONFIG_USB_ETHER
 	usb_ether_init();
 #endif
 
+#ifdef CONFIG_USB_GADGET
+	usb_gadget_init();
+#endif
+
+	if(env_get("bootcmd") == NULL){
+		env_set("bootcmd", CONFIG_BOOTCOMMAND);
+	}
+
 	return 0;
 }
 
diff --git a/cmd/usb_mass_storage.c b/cmd/usb_mass_storage.c
index c5c6899787..09e0804f17 100644
--- a/cmd/usb_mass_storage.c
+++ b/cmd/usb_mass_storage.c
@@ -56,7 +56,7 @@ static int ums_init(const char *devtype, const char *devnums_part_str)
 	char *s, *t, *devnum_part_str, *name;
 	struct blk_desc *block_dev;
 	disk_partition_t info;
-	int partnum;
+	int partnum = 0;
 	int ret = -1;
 	struct ums *ums_new;
 
diff --git a/common/spl/Kconfig b/common/spl/Kconfig
index 9d52b75cb4..5ccf611dda 100644
--- a/common/spl/Kconfig
+++ b/common/spl/Kconfig
@@ -1107,6 +1107,15 @@ config SYS_SPI_U_BOOT_OFFS
 	 Address within SPI-Flash from where the u-boot payload is fetched
 	 from.
 
+config SYS_SPI_NAND_U_BOOT_OFFS
+	hex "address of u-boot payload in SPI NAND flash"
+	default 0xd000 if ARCH_SUNXI
+	default 0x0
+	depends on SPL_SPI_LOAD || SPL_SPINAND_SUNXI
+	help
+	 Address within SPI-NAND Flash from where the u-boot payload is fetched
+	 from.
+
 config SPL_THERMAL
 	bool "Driver support for thermal devices"
 	help
diff --git a/common/spl/spl.c b/common/spl/spl.c
index 932e6ab98a..df13f5ef6e 100644
--- a/common/spl/spl.c
+++ b/common/spl/spl.c
@@ -579,8 +579,25 @@ static int boot_from_devices(struct spl_image_info *spl_image,
 
 		loader = spl_ll_find_loader(spl_boot_list[i]);
 #if defined(CONFIG_SPL_SERIAL_SUPPORT) && defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
-		if (loader)
+		if (loader) {
 			printf("Trying to boot from %s\n", loader->name);
+#if defined(CONFIG_MACH_SUN8I_V3S) || defined(CONFIG_MACH_SUN8I_S3)
+			switch (spl_boot_list[i]) {
+				case BOOT_DEVICE_MMC1:
+					writeb(0, CONFIG_SUNXI_SRAM_ADDRESS + 0x6fff);
+					break;
+				case BOOT_DEVICE_MMC2:
+					writeb(2, CONFIG_SUNXI_SRAM_ADDRESS + 0x6fff);
+					break;
+				case BOOT_DEVICE_SPI:
+					writeb(3, CONFIG_SUNXI_SRAM_ADDRESS + 0x6fff);
+					break;
+				default:
+					writeb(-1, CONFIG_SUNXI_SRAM_ADDRESS + 0x6fff);
+					break;
+			}
+#endif
+		}
 		else
 			puts(SPL_TPL_PROMPT "Unsupported Boot Device!\n");
 #endif
diff --git a/configs/allwinner_s3_generic_defconfig b/configs/allwinner_s3_generic_defconfig
index 2c368215ed..0eace0ad6a 100644
--- a/configs/allwinner_s3_generic_defconfig
+++ b/configs/allwinner_s3_generic_defconfig
@@ -2,6 +2,13 @@ CONFIG_ARM=y
 CONFIG_ARCH_SUNXI=y
 CONFIG_MACH_SUN8I_S3=y
 
+CONFIG_DRAM_CLK=360
+CONFIG_DRAM_ZQ=14779
+CONFIG_SUN8I_EMAC=y
+CONFIG_DM_ETH=y
+CONFIG_MII=y
+CONFIG_DM_MDIO_MUX=y
+
 CONFIG_DEFAULT_DEVICE_TREE="sun8i-s3-generic"
 CONFIG_SPL=y
 CONFIG_CMD_BOOTMENU=y
@@ -9,12 +16,8 @@ CONFIG_CMD_MEMINFO=y
 CONFIG_BOOTDELAY=0
 
 CONFIG_NETDEVICES=y
-CONFIG_SUN8I_EMAC=y
 CONFIG_NET_RANDOM_ETHADDR=y
 
-CONFIG_DM_SPI=y
-CONFIG_SUNXI_SPI=y
-
 CONFIG_MMC=y
 CONFIG_MMC_SUNXI_SLOT_EXTRA=2
 CONFIG_MMC0_CD_PIN="PF6"
@@ -30,25 +33,77 @@ CONFIG_DM_PWM=y
 CONFIG_PWM_SUNXI=y
 CONFIG_BACKLIGHT_PWM=y
 
+# USB
+CONFIG_CMD_DFU=y
+CONFIG_PHY=y
+CONFIG_PHY_SUN4I_USB=y
 CONFIG_USB_GADGET_VBUS_DRAW=250
-
 CONFIG_USB_MUSB_GADGET=y
 CONFIG_USB_MUSB_SUNXI=y
 CONFIG_USB_MUSB_DISABLE_BULK_COMBINE_SPLIT=y
 CONFIG_USB_MUSB_PIO_ONLY=y
 CONFIG_USB_STORAGE=y
-
-CONFIG_PHY=y
-CONFIG_PHY_SUN4I_USB=y
-
 CONFIG_USB_EHCI_HCD=y
-CONFIG_USB_EHCI_GENERIC=y
 CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_OHCI_GENERIC=y
-
 CONFIG_CMD_USB_MASS_STORAGE=y
-
+CONFIG_USB_GADGET_DOWNLOAD=y
 CONFIG_CMD_FASTBOOT=y
 CONFIG_FASTBOOT_FLASH_MMC=y
 CONFIG_FASTBOOT_FLASH_MMC_DEV=1
 CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
+
+# UBI
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_FASTMAP=y
+CONFIG_MTD_UBI_FASTMAP_AUTOCONVERT=1
+CONFIG_CMD_UBI=y
+CONFIG_CMD_UBIFS=y
+CONFIG_RBTREE=y
+CONFIG_MTD_DEVICE=y
+CONFIG_MTD_PARTITIONS=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_LZO=y
+CONFIG_LZMA=y
+
+# ENV
+CONFIG_ENV_IS_IN_FAT=n
+CONFIG_ENV_IS_IN_UBI=y
+CONFIG_ENV_UBI_PART="ubi0"
+CONFIG_ENV_UBI_VOLUME="ubootenv"
+CONFIG_ENV_UBI_VOLUME_REDUND="ubootenv2"
+
+
+# BOOT
+CONFIG_MTDIDS_DEFAULT="spi-nand0=0"
+CONFIG_MTDPARTS_DEFAULT="mtdparts=0:1M(boot),-(ubi0)"
+CONFIG_BOOTCOMMAND="ubifsmount ubi0:kernel; ubifsload $kernel_addr_r uImage; ubifsload $fdt_addr_r dtb; bootm 0x41000000 - 0x41800000"
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyS0,115200 earlyprintk panic=5 rootwait ubi.mtd=1,2048 rootfstype=ubifs root=ubi0:rootfs rw"
+
+### NOR
+## SPI
+# CONFIG_SPI=y
+# CONFIG_SPI_BOOT=y
+# CONFIG_SUNXI_SPI=y
+# CONFIG_SPL_SPI_SUPPORT=y
+# CONFIG_SPL_SPI_SUNXI=y
+
+### NAND
+CONFIG_CLK=y
+CONFIG_CLK_SUNXI=y
+CONFIG_CLK_SUN8I_V3S=y
+CONFIG_SUNXI_SPI=y
+CONFIG_SPI_SUNXI=y
+CONFIG_CMD_MTD=y
+CONFIG_MTD=y
+CONFIG_MTD_SPI_NAND=y
+CONFIG_SPI=y
+CONFIG_SPI_MEM=y
+CONFIG_SPL_SPINAND_SUNXI=y
+CONFIG_DM=y
+CONFIG_DM_SPI=y
+CONFIG_CMD_DM=y
+CONFIG_CMD_SPI=y
+CONFIG_SPL_SPINAND_SUNXI_SPL_SIZE=24576
+CONFIG_SPL_SPINAND_SUNXI_UBOOT_PADDING=8192
+CONFIG_SPL_SPINAND_SUNXI_PAGESIZE=2048
diff --git a/drivers/mtd/nand/spi/core.c b/drivers/mtd/nand/spi/core.c
index cd624ec6ae..69d209518a 100644
--- a/drivers/mtd/nand/spi/core.c
+++ b/drivers/mtd/nand/spi/core.c
@@ -661,6 +661,8 @@ static bool spinand_isbad(struct nand_device *nand, const struct nand_pos *pos)
 		.mode = MTD_OPS_RAW,
 	};
 	int ret;
+	struct mtd_oob_region region;
+	int i;
 
 	memset(spinand->oobbuf, 0, 2);
 	ret = spinand_select_target(spinand, pos->target);
@@ -671,8 +673,12 @@ static bool spinand_isbad(struct nand_device *nand, const struct nand_pos *pos)
 	if (ret)
 		return ret;
 
-	if (spinand->oobbuf[0] != 0xff || spinand->oobbuf[1] != 0xff)
-		return true;
+	spinand->eccinfo.ooblayout->rfree(spinand->base.mtd, 0, &region);
+
+	for(i = 0 ; i < req.ooblen && i < region.offset; i++){
+		if (spinand->oobbuf[i] != 0xff)
+			return true;
+	}
 
 	return false;
 }
@@ -707,6 +713,7 @@ static int spinand_markbad(struct nand_device *nand, const struct nand_pos *pos)
 		.oobbuf.out = spinand->oobbuf,
 	};
 	int ret;
+	struct mtd_oob_region region;
 
 	/* Erase block before marking it bad. */
 	ret = spinand_select_target(spinand, pos->target);
@@ -722,6 +729,8 @@ static int spinand_markbad(struct nand_device *nand, const struct nand_pos *pos)
 		return ret;
 
 	memset(spinand->oobbuf, 0, 2);
+	spinand->eccinfo.ooblayout->rfree(spinand->base.mtd, 0, &region);
+	req.ooblen = region.offset < req.ooblen ? region.offset : req.ooblen;
 	return spinand_write_page(spinand, &req);
 }
 
diff --git a/drivers/mtd/nand/spi/gigadevice.c b/drivers/mtd/nand/spi/gigadevice.c
index 0b228dcb5b..d8e1e7d120 100644
--- a/drivers/mtd/nand/spi/gigadevice.c
+++ b/drivers/mtd/nand/spi/gigadevice.c
@@ -107,7 +107,92 @@ static const struct mtd_ooblayout_ops gd5fxgq4xexxg_ooblayout = {
 	.rfree = gd5fxgq4xexxg_ooblayout_free,
 };
 
+static int gd5fxgq4xa_ooblayout_ecc(struct mtd_info *mtd, int section,
+				  struct mtd_oob_region *region)
+{
+	if (section > 3)
+		return -ERANGE;
+
+	region->offset = (16 * section) + 8;
+	region->length = 8;
+
+	return 0;
+}
+
+static int gd5fxgq4xa_ooblayout_free(struct mtd_info *mtd, int section,
+				   struct mtd_oob_region *region)
+{
+	if (section > 3)
+		return -ERANGE;
+
+	if (section) {
+		region->offset = 16 * section;
+		region->length = 8;
+	} else {
+		/* section 0 has one byte reserved for bad block mark */
+		region->offset = 1;
+		region->length = 7;
+	}
+	return 0;
+}
+
+static int gd5fxgq4xa_ecc_get_status(struct spinand_device *spinand,
+					 u8 status)
+{
+	switch (status & STATUS_ECC_MASK) {
+	case STATUS_ECC_NO_BITFLIPS:
+		return 0;
+
+	case GD5FXGQ4XA_STATUS_ECC_1_7_BITFLIPS:
+		/* 1-7 bits are flipped. return the maximum. */
+		return 7;
+
+	case GD5FXGQ4XA_STATUS_ECC_8_BITFLIPS:
+		return 8;
+
+	case STATUS_ECC_UNCOR_ERROR:
+		return -EBADMSG;
+
+	default:
+		break;
+	}
+
+	return -EINVAL;
+}
+
+static const struct mtd_ooblayout_ops gd5fxgq4xa_ooblayout = {
+	.ecc = gd5fxgq4xa_ooblayout_ecc,
+	.rfree = gd5fxgq4xa_ooblayout_free,
+};
+
+static int gd5fxgq5xexxg_ooblayout_free(struct mtd_info *mtd, int section,
+					struct mtd_oob_region *region)
+{
+	if (section)
+		return -ERANGE;
+
+	/* Q5 seems have some bug on OOB ECC */
+	region->offset = 16;
+	region->length = 4;
+
+	return 0;
+}
+
+static const struct mtd_ooblayout_ops gd5fxgq5xexxg_ooblayout = {
+	.ecc = gd5fxgq4xexxg_ooblayout_ecc,
+	.rfree = gd5fxgq5xexxg_ooblayout_free,
+};
+
 static const struct spinand_info gigadevice_spinand_table[] = {
+	SPINAND_INFO("GD5F1GQ4UAxxG", 0xf1,
+		     NAND_MEMORG(1, 2048, 64, 64, 1024, 1, 1, 1),
+		     NAND_ECCREQ(8, 512),
+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
+					      &write_cache_variants,
+					      &update_cache_variants),
+		     0,
+		     SPINAND_ECCINFO(&gd5fxgq4xa_ooblayout,
+				     gd5fxgq4xa_ecc_get_status)),
 	SPINAND_INFO("GD5F1GQ4UExxG", 0xd1,
 		     NAND_MEMORG(1, 2048, 128, 64, 1024, 1, 1, 1),
 		     NAND_ECCREQ(8, 512),
@@ -117,6 +202,15 @@ static const struct spinand_info gigadevice_spinand_table[] = {
 		     0,
 		     SPINAND_ECCINFO(&gd5fxgq4xexxg_ooblayout,
 				     gd5fxgq4xexxg_ecc_get_status)),
+	SPINAND_INFO("GD5F1GQ5UExxG", 0x51,
+		     NAND_MEMORG(1, 2048, 128, 64, 1024, 1, 1, 1),
+		     NAND_ECCREQ(4, 512),
+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
+					      &write_cache_variants,
+					      &update_cache_variants),
+		     0,
+		     SPINAND_ECCINFO(&gd5fxgq5xexxg_ooblayout,
+				     gd5fxgq4xexxg_ecc_get_status)),
 };
 
 static int gigadevice_spinand_detect(struct spinand_device *spinand)
diff --git a/drivers/mtd/spi/spi-nor-ids.c b/drivers/mtd/spi/spi-nor-ids.c
index abdf560e02..e3399e63f2 100644
--- a/drivers/mtd/spi/spi-nor-ids.c
+++ b/drivers/mtd/spi/spi-nor-ids.c
@@ -311,6 +311,7 @@ const struct flash_info spi_nor_ids[] = {
 	{ INFO("w25q64cv", 0xef4017, 0, 64 * 1024,  128, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ INFO("w25q128", 0xef4018, 0, 64 * 1024, 256, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ INFO("w25q256", 0xef4019, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+	{ INFO("xt25f128", 0x0b4018, 0, 64 * 1024, 256, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 #endif
 #ifdef CONFIG_SPI_FLASH_XMC
 	/* XMC (Wuhan Xinxin Semiconductor Manufacturing Corp.) */
diff --git a/drivers/net/sun8i_emac.c b/drivers/net/sun8i_emac.c
index 1ae776b446..fbfcdfdf69 100644
--- a/drivers/net/sun8i_emac.c
+++ b/drivers/net/sun8i_emac.c
@@ -52,6 +52,7 @@
 #define RX_TOTAL_BUFSIZE	(CONFIG_ETH_BUFSIZE * CONFIG_RX_DESCR_NUM)
 
 #define H3_EPHY_DEFAULT_VALUE	0x58000
+#define V3S_EPHY_DEFAULT_VALUE  0x38000
 #define H3_EPHY_DEFAULT_MASK	GENMASK(31, 15)
 #define H3_EPHY_ADDR_SHIFT	20
 #define REG_PHY_ADDR_MASK	GENMASK(4, 0)
@@ -107,6 +108,7 @@ enum emac_variant {
 	H3_EMAC,
 	A64_EMAC,
 	R40_GMAC,
+	V3S_EMAC,
 };
 
 struct emac_dma_desc {
@@ -274,7 +276,7 @@ static int sun8i_emac_set_syscon_ephy(struct emac_eth_dev *priv, u32 *reg)
 		 * needs to be configured and powered up before use
 		*/
 		*reg &= ~H3_EPHY_DEFAULT_MASK;
-		*reg |=  H3_EPHY_DEFAULT_VALUE;
+		*reg |= ((priv->variant == V3S_EMAC) ? V3S_EPHY_DEFAULT_VALUE :  H3_EPHY_DEFAULT_VALUE);
 		*reg |= priv->phyaddr << H3_EPHY_ADDR_SHIFT;
 		*reg &= ~H3_EPHY_SHUTDOWN;
 		*reg |= H3_EPHY_SELECT;
@@ -313,7 +315,7 @@ static int sun8i_emac_set_syscon(struct sun8i_eth_pdata *pdata,
 	}
 
 	reg &= ~(SC_ETCS_MASK | SC_EPIT);
-	if (priv->variant == H3_EMAC || priv->variant == A64_EMAC)
+	if (priv->variant == H3_EMAC || priv->variant == V3S_EMAC || priv->variant == A64_EMAC)
 		reg &= ~SC_RMII_EN;
 
 	switch (priv->interface) {
@@ -1028,6 +1030,8 @@ static const struct udevice_id sun8i_emac_eth_ids[] = {
 		.data = (uintptr_t)A83T_EMAC },
 	{.compatible = "allwinner,sun8i-r40-gmac",
 		.data = (uintptr_t)R40_GMAC },
+	{.compatible = "allwinner,sun8i-v3s-emac",
+	    .data = (uintptr_t)V3S_EMAC },
 	{ }
 };
 
diff --git a/drivers/phy/allwinner/phy-sun4i-usb.c b/drivers/phy/allwinner/phy-sun4i-usb.c
index 612c428cf5..2cec2c679a 100644
--- a/drivers/phy/allwinner/phy-sun4i-usb.c
+++ b/drivers/phy/allwinner/phy-sun4i-usb.c
@@ -351,7 +351,7 @@ static int sun4i_usb_phy_xlate(struct phy *phy,
 {
 	struct sun4i_usb_phy_data *data = dev_get_priv(phy->dev);
 
-	if (args->args_count >= data->cfg->num_phys)
+	if (args->args_count > data->cfg->num_phys)
 		return -EINVAL;
 
 	if (data->cfg->missing_phys & BIT(args->args[0]))
diff --git a/drivers/usb/musb-new/musb_core.c b/drivers/usb/musb-new/musb_core.c
index 2574a6fd4b..1468ce7343 100644
--- a/drivers/usb/musb-new/musb_core.c
+++ b/drivers/usb/musb-new/musb_core.c
@@ -1874,6 +1874,7 @@ allocate_instance(struct device *dev,
 	}
 
 	musb->controller = dev;
+	musb->dyn_fifo = config->dyn_fifo;
 
 	musb->dyn_fifo = config->dyn_fifo;
 	return musb;
diff --git a/drivers/usb/musb-new/sunxi.c b/drivers/usb/musb-new/sunxi.c
index 98bf736978..311d32469b 100644
--- a/drivers/usb/musb-new/sunxi.c
+++ b/drivers/usb/musb-new/sunxi.c
@@ -467,7 +467,7 @@ static int musb_usb_probe(struct udevice *dev)
 
 	ret = generic_phy_get_by_name(dev, "usb", &glue->phy);
 	if (ret) {
-		pr_err("failed to get usb PHY\n");
+		pr_err("sunxi failed to get usb PHY\n");
 		return ret;
 	}
 
diff --git a/drivers/video/sunxi/sunxi_lcd.c b/drivers/video/sunxi/sunxi_lcd.c
index bc0a782a1c..4df80410a0 100644
--- a/drivers/video/sunxi/sunxi_lcd.c
+++ b/drivers/video/sunxi/sunxi_lcd.c
@@ -27,10 +27,22 @@ static void sunxi_lcdc_config_pinmux(void)
 #if defined(CONFIG_MACH_SUN50I) || defined(CONFIG_MACH_SUN8I_V3S) || defined(CONFIG_MACH_SUN8I_S3)
 	int pin;
 
-	for (pin = SUNXI_GPD(0); pin <= SUNXI_GPD(21); pin++) {
-		sunxi_gpio_set_cfgpin(pin, SUNXI_GPD_LCD0);
-		sunxi_gpio_set_drv(pin, 3);
-	}
+#if defined(CONFIG_MACH_SUN8I_V3S)
+#define SUN8I_V3S_GPE_LCD 3
+        for (pin = SUNXI_GPE(0); pin <= SUNXI_GPE(24); pin++) {
+                if (pin >= SUNXI_GPE(20) && pin <= SUNXI_GPE(22))
+                        continue; /* These pins are not LCD */
+                sunxi_gpio_set_cfgpin(pin, SUN8I_V3S_GPE_LCD);
+        }
+        printf("init v3s gpio e for lcd\n");
+#elif defined(CONFIG_MACH_SUN8I_S3)
+        for (pin = SUNXI_GPD(0); pin <= SUNXI_GPD(21); pin++) {
+                sunxi_gpio_set_cfgpin(pin, SUNXI_GPD_LCD0);
+                sunxi_gpio_set_drv(pin, 3);
+        }
+        printf("init s3 gpio e for lcd\n");
+#endif
+
 #endif
 }
 
