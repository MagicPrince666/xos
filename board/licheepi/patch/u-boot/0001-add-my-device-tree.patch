diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index bbe1887623..9a5d6b2347 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -546,6 +546,7 @@ dtb-$(CONFIG_MACH_SUN8I_R40) += \
 	sun8i-r40-bananapi-m2-ultra.dtb \
 	sun8i-v40-bananapi-m2-berry.dtb
 dtb-$(CONFIG_MACH_SUN8I_V3S) += \
+	sun8i-v3s-prince.dtb \
 	sun8i-v3s-licheepi-zero.dtb 
 dtb-$(CONFIG_MACH_SUN8I_S3) += \
 	sun8i-s3-generic.dtb
diff --git a/arch/arm/include/asm/arch-sunxi/clock_sun6i.h b/arch/arm/include/asm/arch-sunxi/clock_sun6i.h
index 8001a81b8f..6c015f2f94 100644
--- a/arch/arm/include/asm/arch-sunxi/clock_sun6i.h
+++ b/arch/arm/include/asm/arch-sunxi/clock_sun6i.h
@@ -463,6 +463,7 @@ struct sunxi_ccm_reg {
 #ifdef CONFIG_MACH_SUN8I_R40
 #define AHB_RESET_OFFSET_SATA		24
 #endif
+#define AHB_RESET_OFFSET_OTG		24
 #define AHB_RESET_OFFSET_GMAC		17
 #define AHB_RESET_OFFSET_MCTL		14
 #define AHB_RESET_OFFSET_MMC3		11
diff --git a/arch/arm/mach-sunxi/Kconfig b/arch/arm/mach-sunxi/Kconfig
index b7cb87a98f..3a46b14b05 100644
--- a/arch/arm/mach-sunxi/Kconfig
+++ b/arch/arm/mach-sunxi/Kconfig
@@ -262,6 +262,7 @@ config MACH_SUN8I_V3S
 	select SUNXI_DRAM_DW
 	select SUNXI_DRAM_DW_16BIT
 	select SUPPORT_SPL
+	select SUNXI_DE2
 
 config MACH_SUN8I_S3
 	bool "sun8i (Allwinner S3)"
diff --git a/arch/arm/mach-sunxi/spl_spi_sunxi.c b/arch/arm/mach-sunxi/spl_spi_sunxi.c
index a3997b2590..d67fab2194 100644
--- a/arch/arm/mach-sunxi/spl_spi_sunxi.c
+++ b/arch/arm/mach-sunxi/spl_spi_sunxi.c
@@ -8,6 +8,7 @@
 #include <asm/gpio.h>
 #include <asm/io.h>
 #include <linux/libfdt.h>
+#include <asm/arch/spl.h>
 
 #ifdef CONFIG_SPL_OS_BOOT
 #error CONFIG_SPL_OS_BOOT is not supported yet
@@ -85,6 +86,7 @@
 
 #define SPI0_CLK_DIV_BY_2           0x1000
 #define SPI0_CLK_DIV_BY_4           0x1001
+#define SPI0_CLK_DIV_BY_32          0x100f
 
 /*****************************************************************************/
 
@@ -116,7 +118,9 @@ static void spi0_pinmux_setup(unsigned int pin_function)
 static bool is_sun6i_gen_spi(void)
 {
 	return IS_ENABLED(CONFIG_SUNXI_GEN_SUN6I) ||
-	       IS_ENABLED(CONFIG_MACH_SUN50I_H6);
+	       IS_ENABLED(CONFIG_MACH_SUN50I_H6) ||
+		   IS_ENABLED(CONFIG_MACH_SUN8I_V3S) ||
+		   IS_ENABLED(CONFIG_MACH_SUN8I_S3);
 }
 
 static uintptr_t spi0_base_address(void)
@@ -267,38 +271,144 @@ static void sunxi_spi0_read_data(u8 *buf, u32 addr, u32 bufsize,
 	udelay(1);
 }
 
+static void spi0_transmit(
+				 void *send, u32 ssize,
+				 void *recv, u32 rsize)
+{
+	u8 *sbuf = send;
+	u8 *rbuf = recv;
+	uintptr_t base = spi0_base_address();
+	if (is_sun6i_gen_spi()) {
+		sunxi_spi0_transmit(
+					 sbuf, ssize,
+					 rbuf, rsize,
+					 base + SUN6I_SPI0_TCR,
+					 SUN6I_TCR_XCH,
+					 base + SUN6I_SPI0_FIFO_STA,
+					 base + SUN6I_SPI0_TXD,
+					 base + SUN6I_SPI0_RXD,
+					 base + SUN6I_SPI0_MBC,
+					 base + SUN6I_SPI0_MTC,
+					 base + SUN6I_SPI0_BCC);
+	} else {
+		sunxi_spi0_transmit(
+					 sbuf, ssize,
+					 rbuf, rsize,
+					 base + SUN4I_SPI0_CTL,
+					 SUN4I_CTL_XCH,
+					 base + SUN4I_SPI0_FIFO_STA,
+					 base + SUN4I_SPI0_TX,
+					 base + SUN4I_SPI0_RX,
+					 base + SUN4I_SPI0_BC,
+					 base + SUN4I_SPI0_TC,
+					 0);
+	}
+}
+
+enum flashtype
+{
+	FLASHTYPE_UNINIT,
+	FLASHTYPE_NOR,
+	FLASHTYPE_NAND,
+};
+
+static enum flashtype spi0_get_flash_type(void)
+{
+	static enum flashtype type;
+	static u8 chipid[2];
+	if(type == FLASHTYPE_UNINIT)
+	{
+		type = FLASHTYPE_NOR;
+		spi0_transmit("\x9f\x00", 2, chipid, 2); // Read Chip ID
+		if (!memcmp(chipid, "\xc8\xf1", 2)) {
+			printf("SPI-NAND: GigaDevice GD5F1GQ4UAYIG\n");
+			type = FLASHTYPE_NAND;
+		}
+		else if (!memcmp(chipid, "\xc8\x51", 2)) {
+			printf("SPI-NAND: GigaDevice GD5F1GQ5UEYIG\n");
+			type = FLASHTYPE_NAND;
+		}
+		else if (!memcmp(chipid, "\xef\xaa", 2)) {
+			printf("SPI-NAND: Winbond W25N01G\n");
+			type = FLASHTYPE_NAND;
+		}
+		else if (!memcmp(chipid, "\xef\xab", 2)) {
+			printf("SPI-NAND: Winbond W25M02GV\n");
+			type = FLASHTYPE_NAND;
+		}
+	}
+	return type;
+}
+
+static u32 nandpage = -1;
+
+static u32 spi0_read_small_data(void *buf, u32 addr, u32 len)
+{
+	switch(spi0_get_flash_type())
+	{
+	case FLASHTYPE_NAND:
+	{
+		u32 page, wrap;
+		page = addr >> 11;
+		if (nandpage != page) {
+			u8 readcache[] = {0x13, (u8)(page >> 16), (u8)(page >> 8), (u8)(page)};
+			spi0_transmit(readcache, 4, NULL, 0);
+			udelay(300);
+			nandpage = page;
+		}
+		addr &= 0x7FF;
+		if (len + addr > 0x800) 
+			len = 0x800 - addr;
+		if (len > 0 && len <= 16) {
+            wrap = 12;
+        } else if(len > 16 && len <= 64) {
+            wrap = 8;
+        } else if(len > 65 && len <= 2048) {
+            wrap = 4;
+        } else {
+            wrap = 0;
+        }
+		switch(wrap)
+		{
+		case 12:
+			if((addr & 0xF) + len > 16) wrap = 8;
+			break;
+		case 8:
+			if((addr & 0x3F) + len > 65) wrap = 4;
+			break;
+		default:
+			wrap = 0;
+			break;
+		}
+		u8 read[] = {0x03, (u8)((addr >> 8) & 0xF) | (wrap << 4), addr & 0xFF, 0};
+		spi0_transmit(read, 4, buf, len);
+	}
+	break;
+	default:
+	{
+		u8 read[] = {0x03, (u8)(addr >> 16), (u8)(addr >> 8), (u8)(addr)};
+		spi0_transmit(read, 4, buf, len);
+	}
+	break;
+	}
+	return len;
+}
+
+/*****************************************************************************/
+
+#define SPI_READ_MAX_SIZE 60 /* FIFO size, minus 4 bytes of the header */
+
 static void spi0_read_data(void *buf, u32 addr, u32 len)
 {
 	u8 *buf8 = buf;
 	u32 chunk_len;
-	uintptr_t base = spi0_base_address();
 
 	while (len > 0) {
 		chunk_len = len;
 		if (chunk_len > SPI_READ_MAX_SIZE)
 			chunk_len = SPI_READ_MAX_SIZE;
 
-		if (is_sun6i_gen_spi()) {
-			sunxi_spi0_read_data(buf8, addr, chunk_len,
-					     base + SUN6I_SPI0_TCR,
-					     SUN6I_TCR_XCH,
-					     base + SUN6I_SPI0_FIFO_STA,
-					     base + SUN6I_SPI0_TXD,
-					     base + SUN6I_SPI0_RXD,
-					     base + SUN6I_SPI0_MBC,
-					     base + SUN6I_SPI0_MTC,
-					     base + SUN6I_SPI0_BCC);
-		} else {
-			sunxi_spi0_read_data(buf8, addr, chunk_len,
-					     base + SUN4I_SPI0_CTL,
-					     SUN4I_CTL_XCH,
-					     base + SUN4I_SPI0_FIFO_STA,
-					     base + SUN4I_SPI0_TX,
-					     base + SUN4I_SPI0_RX,
-					     base + SUN4I_SPI0_BC,
-					     base + SUN4I_SPI0_TC,
-					     0);
-		}
+		chunk_len = spi0_read_small_data(buf8, addr, chunk_len);
 
 		len  -= chunk_len;
 		buf8 += chunk_len;
@@ -320,12 +430,26 @@ static int spl_spi_load_image(struct spl_image_info *spl_image,
 			      struct spl_boot_device *bootdev)
 {
 	int ret = 0;
+	u32 uboot_addr;
 	struct image_header *header;
 	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE);
+	uboot_addr = CONFIG_SYS_SPI_U_BOOT_OFFS;
 
 	spi0_init();
 
-	spi0_read_data((void *)header, CONFIG_SYS_SPI_U_BOOT_OFFS, 0x40);
+#if defined(CONFIG_MACH_SUN8I_V3S) || defined(CONFIG_MACH_SUN8I_S3)
+	unsigned char *buffer = (unsigned char *)(CONFIG_SYS_TEXT_BASE);
+	spi0_read_data(buffer, 0, 16);
+	if (!is_boot0_magic(buffer + 4)) {
+		return -1;
+	}
+	if (spi0_get_flash_type() == FLASHTYPE_NAND) {
+		printf("SPI-NAND: U-Boot address: %u\n", CONFIG_SYS_SPI_NAND_U_BOOT_OFFS);
+		uboot_addr = CONFIG_SYS_SPI_NAND_U_BOOT_OFFS;
+	}
+#endif
+	
+	spi0_read_data((void *)header, uboot_addr, 0x40);
 
         if (IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
 		image_get_magic(header) == FDT_MAGIC) {
@@ -338,14 +462,14 @@ static int spl_spi_load_image(struct spl_image_info *spl_image,
 		load.bl_len = 1;
 		load.read = spi_load_read;
 		ret = spl_load_simple_fit(spl_image, &load,
-					  CONFIG_SYS_SPI_U_BOOT_OFFS, header);
+					  uboot_addr, header);
 	} else {
 		ret = spl_parse_image_header(spl_image, header);
 		if (ret)
 			return ret;
 
 		spi0_read_data((void *)spl_image->load_addr,
-			       CONFIG_SYS_SPI_U_BOOT_OFFS, spl_image->size);
+			       uboot_addr, spl_image->size);
 	}
 
 	spi0_deinit();
diff --git a/board/sunxi/board.c b/board/sunxi/board.c
index 769530412b..dd82e284b0 100644
--- a/board/sunxi/board.c
+++ b/board/sunxi/board.c
@@ -846,6 +846,16 @@ static void setup_environment(const void *fdt)
 		}
 	}
 }
+static int usb_gadget_init(void)
+{
+	int ret;
+	struct udevice *usb_dev;
+	ret = uclass_first_device(UCLASS_USB_GADGET_GENERIC, &usb_dev);
+	if (!usb_dev || ret) {
+		pr_err("No USB gadget device found\n");
+	}
+	return ret;
+}
 
 int misc_init_r(void)
 {
@@ -867,12 +877,35 @@ int misc_init_r(void)
 		env_set("mmc_bootdev", "1");
 	}
 
+	switch (boot) {
+		case BOOT_DEVICE_MMC1:
+			env_set("boot_device", "mmc0");
+			break;
+		case BOOT_DEVICE_MMC2:
+			env_set("boot_device", "mmc1");
+			break;
+		case BOOT_DEVICE_SPI:
+			env_set("boot_device", "spi");
+			break;
+		default:
+			env_set("boot_device", "fel");
+			break;
+	}
+
 	setup_environment(gd->fdt_blob);
 
 #ifdef CONFIG_USB_ETHER
 	usb_ether_init();
 #endif
 
+#ifdef CONFIG_USB_GADGET
+	usb_gadget_init();
+#endif
+
+	if(env_get("bootcmd") == NULL){
+		env_set("bootcmd", CONFIG_BOOTCOMMAND);
+	}
+
 	return 0;
 }
 
diff --git a/cmd/usb_mass_storage.c b/cmd/usb_mass_storage.c
index c5c6899787..09e0804f17 100644
--- a/cmd/usb_mass_storage.c
+++ b/cmd/usb_mass_storage.c
@@ -56,7 +56,7 @@ static int ums_init(const char *devtype, const char *devnums_part_str)
 	char *s, *t, *devnum_part_str, *name;
 	struct blk_desc *block_dev;
 	disk_partition_t info;
-	int partnum;
+	int partnum = 0;
 	int ret = -1;
 	struct ums *ums_new;
 
diff --git a/common/spl/Kconfig b/common/spl/Kconfig
index 9d52b75cb4..143ec8eb3f 100644
--- a/common/spl/Kconfig
+++ b/common/spl/Kconfig
@@ -1107,6 +1107,15 @@ config SYS_SPI_U_BOOT_OFFS
 	 Address within SPI-Flash from where the u-boot payload is fetched
 	 from.
 
+config SYS_SPI_NAND_U_BOOT_OFFS
+	hex "address of u-boot payload in SPI NAND flash"
+	default 0xd000 if ARCH_SUNXI
+	default 0x0
+	depends on SPL_SPI_LOAD || SPL_SPI_SUNXI
+	help
+	 Address within SPI-NAND Flash from where the u-boot payload is fetched
+	 from.
+
 config SPL_THERMAL
 	bool "Driver support for thermal devices"
 	help
diff --git a/common/spl/spl.c b/common/spl/spl.c
index 932e6ab98a..df13f5ef6e 100644
--- a/common/spl/spl.c
+++ b/common/spl/spl.c
@@ -579,8 +579,25 @@ static int boot_from_devices(struct spl_image_info *spl_image,
 
 		loader = spl_ll_find_loader(spl_boot_list[i]);
 #if defined(CONFIG_SPL_SERIAL_SUPPORT) && defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
-		if (loader)
+		if (loader) {
 			printf("Trying to boot from %s\n", loader->name);
+#if defined(CONFIG_MACH_SUN8I_V3S) || defined(CONFIG_MACH_SUN8I_S3)
+			switch (spl_boot_list[i]) {
+				case BOOT_DEVICE_MMC1:
+					writeb(0, CONFIG_SUNXI_SRAM_ADDRESS + 0x6fff);
+					break;
+				case BOOT_DEVICE_MMC2:
+					writeb(2, CONFIG_SUNXI_SRAM_ADDRESS + 0x6fff);
+					break;
+				case BOOT_DEVICE_SPI:
+					writeb(3, CONFIG_SUNXI_SRAM_ADDRESS + 0x6fff);
+					break;
+				default:
+					writeb(-1, CONFIG_SUNXI_SRAM_ADDRESS + 0x6fff);
+					break;
+			}
+#endif
+		}
 		else
 			puts(SPL_TPL_PROMPT "Unsupported Boot Device!\n");
 #endif
diff --git a/configs/allwinner_s3_generic_defconfig b/configs/allwinner_s3_generic_defconfig
index 2c368215ed..f0dd4deadd 100644
--- a/configs/allwinner_s3_generic_defconfig
+++ b/configs/allwinner_s3_generic_defconfig
@@ -47,8 +47,14 @@ CONFIG_USB_OHCI_HCD=y
 CONFIG_USB_OHCI_GENERIC=y
 
 CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_USB_GADGET_DOWNLOAD=y
 
 CONFIG_CMD_FASTBOOT=y
 CONFIG_FASTBOOT_FLASH_MMC=y
 CONFIG_FASTBOOT_FLASH_MMC_DEV=1
 CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
+
+CONFIG_SPL_SPI_SUNXI=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_SPI_SUNXI=y
diff --git a/drivers/phy/allwinner/phy-sun4i-usb.c b/drivers/phy/allwinner/phy-sun4i-usb.c
index 612c428cf5..2cec2c679a 100644
--- a/drivers/phy/allwinner/phy-sun4i-usb.c
+++ b/drivers/phy/allwinner/phy-sun4i-usb.c
@@ -351,7 +351,7 @@ static int sun4i_usb_phy_xlate(struct phy *phy,
 {
 	struct sun4i_usb_phy_data *data = dev_get_priv(phy->dev);
 
-	if (args->args_count >= data->cfg->num_phys)
+	if (args->args_count > data->cfg->num_phys)
 		return -EINVAL;
 
 	if (data->cfg->missing_phys & BIT(args->args[0]))
diff --git a/drivers/usb/musb-new/musb_core.c b/drivers/usb/musb-new/musb_core.c
index 2574a6fd4b..1468ce7343 100644
--- a/drivers/usb/musb-new/musb_core.c
+++ b/drivers/usb/musb-new/musb_core.c
@@ -1874,6 +1874,7 @@ allocate_instance(struct device *dev,
 	}
 
 	musb->controller = dev;
+	musb->dyn_fifo = config->dyn_fifo;
 
 	musb->dyn_fifo = config->dyn_fifo;
 	return musb;
diff --git a/drivers/usb/musb-new/sunxi.c b/drivers/usb/musb-new/sunxi.c
index 98bf736978..311d32469b 100644
--- a/drivers/usb/musb-new/sunxi.c
+++ b/drivers/usb/musb-new/sunxi.c
@@ -467,7 +467,7 @@ static int musb_usb_probe(struct udevice *dev)
 
 	ret = generic_phy_get_by_name(dev, "usb", &glue->phy);
 	if (ret) {
-		pr_err("failed to get usb PHY\n");
+		pr_err("sunxi failed to get usb PHY\n");
 		return ret;
 	}
 
diff --git a/drivers/video/sunxi/sunxi_lcd.c b/drivers/video/sunxi/sunxi_lcd.c
index bc0a782a1c..4df80410a0 100644
--- a/drivers/video/sunxi/sunxi_lcd.c
+++ b/drivers/video/sunxi/sunxi_lcd.c
@@ -27,10 +27,22 @@ static void sunxi_lcdc_config_pinmux(void)
 #if defined(CONFIG_MACH_SUN50I) || defined(CONFIG_MACH_SUN8I_V3S) || defined(CONFIG_MACH_SUN8I_S3)
 	int pin;
 
-	for (pin = SUNXI_GPD(0); pin <= SUNXI_GPD(21); pin++) {
-		sunxi_gpio_set_cfgpin(pin, SUNXI_GPD_LCD0);
-		sunxi_gpio_set_drv(pin, 3);
-	}
+#if defined(CONFIG_MACH_SUN8I_V3S)
+#define SUN8I_V3S_GPE_LCD 3
+        for (pin = SUNXI_GPE(0); pin <= SUNXI_GPE(24); pin++) {
+                if (pin >= SUNXI_GPE(20) && pin <= SUNXI_GPE(22))
+                        continue; /* These pins are not LCD */
+                sunxi_gpio_set_cfgpin(pin, SUN8I_V3S_GPE_LCD);
+        }
+        printf("init v3s gpio e for lcd\n");
+#elif defined(CONFIG_MACH_SUN8I_S3)
+        for (pin = SUNXI_GPD(0); pin <= SUNXI_GPD(21); pin++) {
+                sunxi_gpio_set_cfgpin(pin, SUNXI_GPD_LCD0);
+                sunxi_gpio_set_drv(pin, 3);
+        }
+        printf("init s3 gpio e for lcd\n");
+#endif
+
 #endif
 }
 
